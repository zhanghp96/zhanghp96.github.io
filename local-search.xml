<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>C++实现Delaunay三角剖分算法</title>
    <link href="/2021/01/25/delaunay/"/>
    <url>/2021/01/25/delaunay/</url>
    
    <content type="html"><![CDATA[<h1 id="C-实现Delaunay三角剖分算法"><a href="#C-实现Delaunay三角剖分算法" class="headerlink" title="C++实现Delaunay三角剖分算法"></a>C++实现Delaunay三角剖分算法</h1><p>该算法的伪代码为：</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs glsl">input: 顶点列表(<span class="hljs-keyword">vertices</span>)　　　　　　　　　　　　　　　　　　　　  　<span class="hljs-comment">//vertices为外部生成的随机或乱序顶点列表</span><br>output:已确定的三角形列表(<span class="hljs-keyword">triangles</span>)<br>　　　　初始化顶点列表<br>　　　　创建索引列表(indices = new Array(<span class="hljs-keyword">vertices</span>.<span class="hljs-built_in">length</span>))　　　　<span class="hljs-comment">//indices数组中的值为0,1,2,3,......,vertices.length-1</span><br>　　　　基于<span class="hljs-keyword">vertices</span>中的顶点x坐标对indices进行sort　　  　　　　　  <span class="hljs-comment">//sort后的indices值顺序为顶点坐标x从小到大排序（也可对y坐标，本例中针对x坐标）</span><br>　　　　确定超级三角形<br>　　　　将超级三角形保存至未确定三角形列表（temp <span class="hljs-keyword">triangles</span>）<br>　　　　将超级三角形push到<span class="hljs-keyword">triangles</span>列表<br>　　　　遍历基于indices顺序的<span class="hljs-keyword">vertices</span>中每一个点　　　　　　　　　  　<span class="hljs-comment">//基于indices后，则顶点则是由x从小到大出现</span><br>　　　　　　初始化边缓存数组（edge <span class="hljs-keyword">buffer</span>）<br>　　　　　　遍历temp <span class="hljs-keyword">triangles</span>中的每一个三角形<br>　　　　　　　　计算该三角形的圆心和半径<br>　　　　　　　　如果该点在外接圆的右侧<br>　　　　　　　　　　则该三角形为Delaunay三角形，保存到<span class="hljs-keyword">triangles</span><br>　　　　　　　　　　并在temp里去除掉<br>　　　　　　　　　　跳过<br>　　　　　　　　如果该点在外接圆外（即也不是外接圆右侧）<br>　　　　　　　　　　则该三角形为不确定        　　　　　　　　　     <span class="hljs-comment">//后面会在问题中讨论</span><br>　　　　　　　　　　跳过<br>　　　　　　　　如果该点在外接圆内<br>　　　　　　　　　　则该三角形不为Delaunay三角形<br>　　　　　　　　　　将三边保存至edge <span class="hljs-keyword">buffer</span><br>　　　　　　　　　　在temp中去除掉该三角形<br>　　　　　　对edge <span class="hljs-keyword">buffer</span>进行去重<br>　　　　　　将edge <span class="hljs-keyword">buffer</span>中的边与当前的点进行组合成若干三角形并保存至temp <span class="hljs-keyword">triangles</span>中<br>　　　　将<span class="hljs-keyword">triangles</span>与temp <span class="hljs-keyword">triangles</span>进行合并<br>　　　　除去与超级三角形有关的三角形<br>end<br></code></pre></td></tr></table></figure><p>我的C++实现：<br>Delaunay.h</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;numeric&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;climits&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;exception&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>;<br><span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">list</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Delaunay</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">size_t</span>&gt; <span class="hljs-title">triangulate</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt;&gt; &amp;vertices)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">size_t</span>&gt; ret;<br>m_vertices = vertices;<br><span class="hljs-keyword">int</span> n = m_vertices.<span class="hljs-built_in">size</span>();<br><br><span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">3</span>)<br><span class="hljs-keyword">return</span> ret;<br><br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">size_t</span>&gt; <span class="hljs-title">indices</span><span class="hljs-params">(n)</span></span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>indices[i] = i;<br><br><span class="hljs-built_in">std</span>::sort(indices.<span class="hljs-built_in">begin</span>(), indices.<span class="hljs-built_in">end</span>(), [<span class="hljs-keyword">this</span>](<span class="hljs-keyword">size_t</span> first, <span class="hljs-keyword">size_t</span> last)<br>&#123;<br><span class="hljs-keyword">return</span> m_vertices[first][<span class="hljs-number">0</span>] &lt; m_vertices[last][<span class="hljs-number">0</span>];<br>&#125;);<br><br>_superTriangle();<br>m_vertices.push_back(m_superTriangle[<span class="hljs-number">0</span>]);<br>m_vertices.push_back(m_superTriangle[<span class="hljs-number">1</span>]);<br>m_vertices.push_back(m_superTriangle[<span class="hljs-number">2</span>]);<br><br><span class="hljs-comment">// 待判定是否为Delaunay三角形</span><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt;&gt; triangle&#123; &#123; _circumcircle(n + <span class="hljs-number">0</span>, n + <span class="hljs-number">1</span>, n + <span class="hljs-number">2</span>) &#125; &#125;;<br><span class="hljs-comment">// 已判定</span><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt;&gt; delaunayTriangle;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; indices.<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">size_t</span>&gt;&gt; edges;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt;&gt; tmp;<br><span class="hljs-keyword">size_t</span> c = indices[i];<br><span class="hljs-comment">// 判断点加入后，triangle里的各个三角形是否是Delaunay三角形</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> <span class="hljs-keyword">const</span>&amp; tri : triangle)<br>&#123;<br><span class="hljs-keyword">double</span> dx = vertices[c][<span class="hljs-number">0</span>] - tri[<span class="hljs-number">3</span>];<br><span class="hljs-keyword">double</span> r = tri[<span class="hljs-number">5</span>];<br><span class="hljs-comment">// 点在三角形外接圆的右边，直接判定为Delaunay三角形</span><br><span class="hljs-keyword">if</span> (dx &gt; <span class="hljs-number">0.0</span> &amp;&amp; dx * dx - r &gt; <span class="hljs-number">1e-6</span>)<br>&#123;<br>delaunayTriangle.push_back(tri);<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-comment">// 点在三角形外接圆的外部但不在右边，此时不确定</span><br><span class="hljs-keyword">double</span> dy = vertices[c][<span class="hljs-number">1</span>] - tri[<span class="hljs-number">4</span>];<br><span class="hljs-keyword">double</span> dist = dx * dx + dy * dy;<br><span class="hljs-keyword">if</span> ((dist - tri[<span class="hljs-number">5</span>]) &gt; EPSILON)<br>&#123;<br>tmp.push_back(tri);<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-comment">// 点在三角形外接圆内部，非Delaunay三角形</span><br>edges.push_back(&#123; <span class="hljs-keyword">size_t</span>(tri[<span class="hljs-number">0</span>]), <span class="hljs-keyword">size_t</span>(tri[<span class="hljs-number">1</span>]) &#125;);<br>edges.push_back(&#123; <span class="hljs-keyword">size_t</span>(tri[<span class="hljs-number">1</span>]), <span class="hljs-keyword">size_t</span>(tri[<span class="hljs-number">2</span>]) &#125;);<br>edges.push_back(&#123; <span class="hljs-keyword">size_t</span>(tri[<span class="hljs-number">2</span>]), <span class="hljs-keyword">size_t</span>(tri[<span class="hljs-number">0</span>]) &#125;);<br><br><span class="hljs-comment">// TODO 点恰好落在三角形外接圆上</span><br>&#125;<br>_dedup(edges);<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;edge : edges)<br>&#123;<br><span class="hljs-keyword">size_t</span> b = edge[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">size_t</span> a = edge[<span class="hljs-number">1</span>];<br>tmp.push_back(_circumcircle(a, b, c));<br>&#125;<br>triangle = tmp;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> <span class="hljs-keyword">const</span>&amp; tri : triangle)<br>delaunayTriangle.push_back(tri);<br>triangle.<span class="hljs-built_in">clear</span>();<br><br><span class="hljs-comment">// 去除superTriangle</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it = delaunayTriangle.<span class="hljs-built_in">begin</span>(); it != delaunayTriangle.<span class="hljs-built_in">end</span>(); it++)<br>&#123;<br><span class="hljs-keyword">if</span> ((*it)[<span class="hljs-number">0</span>] &lt; n &amp;&amp; (*it)[<span class="hljs-number">1</span>] &lt; n &amp;&amp; (*it)[<span class="hljs-number">2</span>] &lt; n)<br>&#123;<br>ret.push_back((*it)[<span class="hljs-number">0</span>]);<br>ret.push_back((*it)[<span class="hljs-number">1</span>]);<br>ret.push_back((*it)[<span class="hljs-number">2</span>]);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-keyword">void</span> _superTriangle()<br>&#123;<br><span class="hljs-keyword">double</span> xmin = DBL_MAX;<br><span class="hljs-keyword">double</span> ymin = DBL_MAX;<br><span class="hljs-keyword">double</span> xmax = -DBL_MAX;<br><span class="hljs-keyword">double</span> ymax = -DBL_MAX;<br><span class="hljs-keyword">double</span> dx, dy, dmax, xmid, ymid;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = m_vertices.<span class="hljs-built_in">size</span>(); i--;)<br>&#123;<br><span class="hljs-keyword">if</span> (m_vertices[i][<span class="hljs-number">0</span>] &lt; xmin) xmin = m_vertices[i][<span class="hljs-number">0</span>];<br><span class="hljs-keyword">if</span> (m_vertices[i][<span class="hljs-number">0</span>] &gt; xmax) xmax = m_vertices[i][<span class="hljs-number">0</span>];<br><span class="hljs-keyword">if</span> (m_vertices[i][<span class="hljs-number">1</span>] &lt; ymin) ymin = m_vertices[i][<span class="hljs-number">0</span>];<br><span class="hljs-keyword">if</span> (m_vertices[i][<span class="hljs-number">0</span>] &gt; ymax) ymax = m_vertices[i][<span class="hljs-number">0</span>];<br>&#125;<br><br>dx = xmax - xmin;<br>dy = ymax - ymin;<br>dmax = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">max</span>(dx, dy);<br>xmid = xmin + dx * <span class="hljs-number">0.5</span>;<br>ymid = ymin + dy * <span class="hljs-number">0.5</span>;<br>m_superTriangle.push_back(&#123; xmid - <span class="hljs-number">20</span> * dmax, ymid -      dmax &#125;);<br>m_superTriangle.push_back(&#123; xmid            , ymid + <span class="hljs-number">20</span> * dmax &#125;);<br>m_superTriangle.push_back(&#123; xmid + <span class="hljs-number">20</span> * dmax, ymid -      dmax &#125;);<br>&#125;<br><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt; _circumcircle(<span class="hljs-keyword">size_t</span> i, <span class="hljs-keyword">size_t</span> j, <span class="hljs-keyword">size_t</span> k)<br>&#123;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt; ret;<br><span class="hljs-keyword">double</span> x1 = m_vertices[i][<span class="hljs-number">0</span>];<br><span class="hljs-keyword">double</span> y1 = m_vertices[i][<span class="hljs-number">1</span>];<br><span class="hljs-keyword">double</span> x2 = m_vertices[j][<span class="hljs-number">0</span>];<br><span class="hljs-keyword">double</span> y2 = m_vertices[j][<span class="hljs-number">1</span>];<br><span class="hljs-keyword">double</span> x3 = m_vertices[k][<span class="hljs-number">0</span>];<br><span class="hljs-keyword">double</span> y3 = m_vertices[k][<span class="hljs-number">1</span>];<br><span class="hljs-keyword">double</span> fabsy1y2 = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">fabs</span>(y1 - y2);<br><span class="hljs-keyword">double</span> fabsy2y3 = <span class="hljs-built_in">std</span>::<span class="hljs-built_in">fabs</span>(y2 - y3);<br><span class="hljs-keyword">double</span> xc, yc, m1, m2, mx1, mx2, my1, my2, dx, dy;<br><span class="hljs-keyword">if</span> (fabsy1y2 &lt; EPSILON &amp;&amp; fabsy2y3 &lt; EPSILON)<br>&#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-built_in">std</span>::exception(<span class="hljs-string">&quot;Eek! Coincident points!&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">if</span> (fabsy1y2 &lt; EPSILON)<br>&#123;<br>m2 = -((x3 - x2) / (y3 - y2));<br>mx2 = (x2 + x3) / <span class="hljs-number">2.0</span>;<br>my2 = (y2 + y3) / <span class="hljs-number">2.0</span>;<br>xc = (x2 + x1) / <span class="hljs-number">2.0</span>;<br>yc = m2 * (xc - mx2) + my2;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (fabsy2y3 &lt; EPSILON)<br>&#123;<br>m1 = -((x2 - x1) / (y2 - y1));<br>mx1 = (x1 + x2) / <span class="hljs-number">2.0</span>;<br>my1 = (y1 + y2) / <span class="hljs-number">2.0</span>;<br>xc = (x3 + x2) / <span class="hljs-number">2.0</span>;<br>yc = m1 * (xc - mx1) + my1;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>m1 = -((x2 - x1) / (y2 - y1));<br>m2 = -((x3 - x2) / (y3 - y2));<br>mx1 = (x1 + x2) / <span class="hljs-number">2.0</span>;<br>mx2 = (x2 + x3) / <span class="hljs-number">2.0</span>;<br>my1 = (y1 + y2) / <span class="hljs-number">2.0</span>;<br>my2 = (y2 + y3) / <span class="hljs-number">2.0</span>;<br>xc = (m1 * mx1 - m2 * mx2 + my2 - my1) / (m1 - m2);<br>yc = (fabsy1y2 &gt; fabsy2y3) ? m1 * (xc - mx1) + my1 : m2 * (xc - mx2) + my2;<br>&#125;<br>dx = x2 - xc;<br>dy = y2 - yc;<br><br><span class="hljs-keyword">return</span>&#123; <span class="hljs-keyword">double</span>(i), <span class="hljs-keyword">double</span>(j), <span class="hljs-keyword">double</span>(k), xc, yc, dx * dx + dy * dy &#125;;<br>&#125;<br><br><span class="hljs-keyword">void</span> _dedup(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">size_t</span>&gt;&gt; &amp;edges)<br>&#123;<br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">bool</span>&gt; <span class="hljs-title">remove_</span><span class="hljs-params">(edges.<span class="hljs-built_in">size</span>(), <span class="hljs-literal">false</span>)</span></span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it1 = edges.<span class="hljs-built_in">begin</span>(); it1 != edges.<span class="hljs-built_in">end</span>(); it1++)<br>&#123;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">size_t</span>&gt; v1 = *it1;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it2 = edges.<span class="hljs-built_in">begin</span>(); it2 != edges.<span class="hljs-built_in">end</span>(); it2++)<br>&#123;<br><span class="hljs-keyword">if</span> (it1 == it2)<br><span class="hljs-keyword">continue</span>;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">size_t</span>&gt; v2 = *it2;<br><span class="hljs-keyword">if</span> ((v1[<span class="hljs-number">0</span>] == v2[<span class="hljs-number">0</span>] &amp;&amp; v1[<span class="hljs-number">1</span>] == v2[<span class="hljs-number">1</span>]) || (v1[<span class="hljs-number">1</span>] == v2[<span class="hljs-number">0</span>] &amp;&amp; v1[<span class="hljs-number">0</span>] == v2[<span class="hljs-number">1</span>]))<br>&#123;<br><span class="hljs-keyword">size_t</span> index1 = <span class="hljs-built_in">std</span>::distance(edges.<span class="hljs-built_in">begin</span>(), it1);<br><span class="hljs-keyword">size_t</span> index2 = <span class="hljs-built_in">std</span>::distance(edges.<span class="hljs-built_in">begin</span>(), it2);<br>remove_[index1] = <span class="hljs-literal">true</span>;<br>remove_[index2] = <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">auto</span> it = <span class="hljs-built_in">std</span>::remove_if(edges.<span class="hljs-built_in">begin</span>(), edges.<span class="hljs-built_in">end</span>(), [&amp;](<span class="hljs-keyword">const</span> <span class="hljs-keyword">auto</span> &amp;edge) &#123;<span class="hljs-keyword">return</span> remove_[&amp;edge - &amp;edges[<span class="hljs-number">0</span>]]; &#125;);<br>edges.erase(it, edges.<span class="hljs-built_in">end</span>());<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt;&gt; m_superTriangle;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt;&gt; m_vertices;<br><br><span class="hljs-keyword">const</span> <span class="hljs-keyword">double</span> EPSILON = <span class="hljs-number">1.0</span> / <span class="hljs-number">1048576.0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>main.cpp</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;random&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;opencv2/opencv.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;Delaunay.h&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">int</span> argc, <span class="hljs-keyword">char</span>** argv)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> <span class="hljs-built_in">width</span> = <span class="hljs-number">1024</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-keyword">int</span> <span class="hljs-built_in">height</span> = <span class="hljs-number">1024</span>;<br><br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">double</span>&gt;&gt; vertices(<span class="hljs-number">1024</span>);<br><span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">double</span> x, y;<br><span class="hljs-built_in">std</span>::random_device e;<br><span class="hljs-function"><span class="hljs-built_in">std</span>::uniform_real_distribution&lt;<span class="hljs-keyword">double</span>&gt; <span class="hljs-title">u</span><span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)</span></span>;<br><span class="hljs-keyword">for</span> (; i &lt; vertices.<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br><span class="hljs-keyword">do</span><br>&#123;<br>x = u(e) - <span class="hljs-number">0.5</span>;<br>y = u(e) - <span class="hljs-number">0.5</span>;<br><br>&#125; <span class="hljs-keyword">while</span> (x * x + y * y &gt; <span class="hljs-number">0.25</span>);<br>x = (x * <span class="hljs-number">0.96875</span> + <span class="hljs-number">0.5</span>) * <span class="hljs-built_in">width</span>;<br>y = (y * <span class="hljs-number">0.96875</span> + <span class="hljs-number">0.5</span>) * <span class="hljs-built_in">height</span>;<br>vertices[i] = &#123; x, y &#125;;<br>&#125;<br>Delaunay delaunay;<br><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">size_t</span>&gt; triangles = delaunay.triangulate(vertices);<br><span class="hljs-function">cv::Mat <span class="hljs-title">img</span><span class="hljs-params">(<span class="hljs-built_in">height</span>, <span class="hljs-built_in">width</span>, CV_8UC3, cv::Scalar(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>))</span></span>;<br><span class="hljs-function">cv::Scalar <span class="hljs-title">color</span><span class="hljs-params">(<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>)</span></span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = triangles.<span class="hljs-built_in">size</span>(); i;)<br>&#123;<br>--i; cv::Point2d p1 = cv::Point2d(vertices[triangles[i]][<span class="hljs-number">0</span>], vertices[triangles[i]][<span class="hljs-number">1</span>]);<br>--i; cv::Point2d p2 = cv::Point2d(vertices[triangles[i]][<span class="hljs-number">0</span>], vertices[triangles[i]][<span class="hljs-number">1</span>]);<br>--i; cv::Point2d p3 = cv::Point2d(vertices[triangles[i]][<span class="hljs-number">0</span>], vertices[triangles[i]][<span class="hljs-number">1</span>]);<br>cv::<span class="hljs-built_in">line</span>(img, p1, p2, color);<br>cv::<span class="hljs-built_in">line</span>(img, p1, p3, color);<br>&#125;<br>cv::namedWindow(<span class="hljs-string">&quot;img&quot;</span>);<br>cv::imshow(<span class="hljs-string">&quot;img&quot;</span>, img);<br>cv::waitKey(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C++给自定义类定义Hash计算</title>
    <link href="/2021/01/05/unordered-map/"/>
    <url>/2021/01/05/unordered-map/</url>
    
    <content type="html"><![CDATA[<h1 id="C-给自定义类定义Hash计算"><a href="#C-给自定义类定义Hash计算" class="headerlink" title="C++给自定义类定义Hash计算"></a>C++给自定义类定义Hash计算</h1><p>给自定义类定义hash计算，可以使用标准库的散列容器 unordered_set 和 unordered_map，有多重方法实现：<br>1）给标准库中的 hash / equal_to实例化一个自定义类的类型；<br>2）自定义函数对象;<br>3）使用lambda表达式</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unordered_map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;functional&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;climits&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;cmath&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unordered_map</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Point</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    Point() = <span class="hljs-keyword">default</span>;<br>    Point(<span class="hljs-keyword">double</span> x, <span class="hljs-keyword">double</span> y) : m_x(x), m_y(y) &#123;&#125;<br><br>    <span class="hljs-keyword">double</span> m_x = <span class="hljs-built_in">std</span>::numeric_limits&lt;<span class="hljs-keyword">double</span>&gt;::quiet_NaN();<br>    <span class="hljs-keyword">double</span> m_y = <span class="hljs-built_in">std</span>::numeric_limits&lt;<span class="hljs-keyword">double</span>&gt;::quiet_NaN();<br>&#125;<br><br><span class="hljs-comment">//给标准库中的 hash / equal_to实例化一个自定义类的类型</span><br><span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span><br>&#123;<br>    <span class="hljs-keyword">template</span>&lt;&gt;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">hash</span>&lt;</span>Point&gt;<br>    &#123;<br>        <span class="hljs-keyword">using</span> result_type = <span class="hljs-keyword">size_t</span>;<br><span class="hljs-keyword">using</span> argument_type = Coordinate;<br><br><span class="hljs-function">result_type <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">const</span> argument_type &amp;p)</span> <span class="hljs-keyword">const</span> </span>&#123;<br><span class="hljs-keyword">double</span> value = p.m_x + p.m_y;<br><span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> bits;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">std</span>::isnan(value))<br>bits = <span class="hljs-number">0xFFF8000000000000</span>;<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">memcpy</span>(&amp;bits, &amp;value, <span class="hljs-keyword">sizeof</span>(bits));<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">size_t</span>(bits ^ (<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">uint64_t</span>&gt;(bits) &gt;&gt; <span class="hljs-number">32</span>));<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-keyword">template</span>&lt;&gt;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">equal_to</span>&lt;</span>Point&gt;<br>    &#123;<br>        <span class="hljs-keyword">using</span> Point = first_argument_type;<br>        <span class="hljs-keyword">using</span> Point = second_argument_type;<br>        <span class="hljs-keyword">using</span> <span class="hljs-keyword">bool</span> = result_type;<br>        <br>        <span class="hljs-function">result_type <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">const</span> first_argument_type &amp;first, <span class="hljs-keyword">const</span> second_argument_type &amp;second)</span></span><br><span class="hljs-function">        </span>&#123;<br>            <span class="hljs-keyword">return</span> (first.m_x - second.m_x) &lt; <span class="hljs-number">1e-8</span> &amp;&amp; (first.m_y - second.m_y) &lt; <span class="hljs-number">1e-8</span>;<br>        &#125;<br>    &#125;; <br>&#125;<br><br><span class="hljs-comment">//函数对象实现</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyHash</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> result_type = <span class="hljs-keyword">size_t</span>;<br>    <span class="hljs-keyword">using</span> argument_type = Coordinate;<br><br>    <span class="hljs-function">result_type <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">const</span> argument_type &amp;p)</span> <span class="hljs-keyword">const</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">double</span> value = p.m_x + p.m_y;<br>        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> bits;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">std</span>::isnan(value))<br>            bits = <span class="hljs-number">0xFFF8000000000000</span>;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-built_in">memcpy</span>(&amp;bits, &amp;value, <span class="hljs-keyword">sizeof</span>(bits));<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">size_t</span>(bits ^ (<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">uint64_t</span>&gt;(bits) &gt;&gt; <span class="hljs-number">32</span>));<br>    &#125;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyEqual</span></span><br><span class="hljs-class">&#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">using</span> Point = first_argument_type;<br>    <span class="hljs-keyword">using</span> Point = second_argument_type;<br>    <span class="hljs-keyword">using</span> <span class="hljs-keyword">bool</span> = result_type;<br><br>    <span class="hljs-function">result_type <span class="hljs-title">operator</span><span class="hljs-params">()</span><span class="hljs-params">(<span class="hljs-keyword">const</span> first_argument_type &amp;first, <span class="hljs-keyword">const</span> second_argument_type &amp;second)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> (first.m_x - second.m_x) &lt; <span class="hljs-number">1e-8</span> &amp;&amp; (first.m_y - second.m_y) &lt; <span class="hljs-number">1e-8</span>;<br>    &#125;<br>&#125;;<br><br><br><span class="hljs-comment">//lambda实现</span><br><span class="hljs-built_in">std</span>::function&lt;<span class="hljs-built_in">std</span>::<span class="hljs-keyword">size_t</span>(<span class="hljs-keyword">const</span> Point &amp;)&gt; lambda_hash = [](<span class="hljs-keyword">const</span> Point &amp;p) <br>&#123;<br>    <span class="hljs-keyword">double</span> value = p.m_x + p.m_y;<br>    <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> bits;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">std</span>::isnan(value))<br>        bits = <span class="hljs-number">0xFFF8000000000000</span>;<br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">memcpy</span>(&amp;bits, &amp;value, <span class="hljs-keyword">sizeof</span>(bits));<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">size_t</span>(bits ^ (<span class="hljs-keyword">static_cast</span>&lt;<span class="hljs-keyword">uint64_t</span>&gt;(bits) &gt;&gt; <span class="hljs-number">32</span>));<br>&#125;;<br><br><span class="hljs-built_in">std</span>::function&lt;<span class="hljs-keyword">bool</span>(<span class="hljs-keyword">const</span> Point&amp;, <span class="hljs-keyword">const</span> Point&amp;)&gt; lambda_equal = [](<span class="hljs-keyword">const</span> Point &amp;first, <span class="hljs-keyword">const</span> Point &amp;second)<br>&#123;<br>    <span class="hljs-keyword">return</span> (first.m_x - second.m_x) &lt; <span class="hljs-number">1e-8</span> &amp;&amp; (first.m_y - second.m_y) &lt; <span class="hljs-number">1e-8</span>;<br>&#125;;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">unordered_map</span>&lt;Point, <span class="hljs-keyword">int</span>&gt; um1;<br>    <span class="hljs-built_in">unordered_map</span>&lt;Point, <span class="hljs-keyword">int</span>, MyHash, MyEqual&gt; um2;<br>    <span class="hljs-built_in">unordered_map</span>&lt;Point, <span class="hljs-keyword">int</span>, <span class="hljs-keyword">decltype</span>(lambda_hash), <span class="hljs-keyword">decltype</span>(lambda_equal)&gt; um3;<br>    <span class="hljs-function">Point <span class="hljs-title">p</span><span class="hljs-params">(<span class="hljs-number">3.14159</span>, <span class="hljs-number">2.71828</span>)</span></span>;<br>    um1.insert(p);<br>    um2.insert(p);<br>    um3.insert(p);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>多元微积分总结</title>
    <link href="/2020/11/02/poisson/"/>
    <url>/2020/11/02/poisson/</url>
    
    <content type="html"><![CDATA[<p>这周在研究有关泊松重建的内容，论文中出现了多元微积分的内容，于是重新学习了一下高等数学的知识，在这里做一个记录。</p><h1 id="1-向量场"><a href="#1-向量场" class="headerlink" title="1. 向量场"></a>1. 向量场</h1><p>二维向量场中，平面上每个点$(x, y)$都有一个以该点为起点的向量$\vec{v}(x, y)$ ，其大小和方向与这个点有关。<br>对向量进行正交分解，即可得到$\vec{v}(x, y)=P(x,y)\vec{i}+Q(x,y)\vec{j}$<br>三维向量场和二维向量场类似，有$\vec{v}(x,y,z)=P\vec{i}+Q\vec{j}+R\vec{k}$<br>物理中的力场、电场、磁场、流量场等，都可以用向量场来进行描述</p><h1 id="2-环量、旋度、斯托克斯公式"><a href="#2-环量、旋度、斯托克斯公式" class="headerlink" title="2. 环量、旋度、斯托克斯公式"></a>2. 环量、旋度、斯托克斯公式</h1><h2 id="2-1-环量"><a href="#2-1-环量" class="headerlink" title="2.1 环量"></a>2.1 环量</h2><p>现在给定一个二维力场$\vec{F}=\vec{v}(x,y)=P\vec{i}+Q\vec{j}$，一个单位质量的质点在其中沿某条曲线$L$运动，如何求该力场中的力做的总功？<br>在某一点$(x,y)$附近，路径切线为$\vec{t}$，令$|\vec{t}|=1$，则做功的微元$dW=\vec{F}\cdot{\vec{t}ds}=\vec{F}\cdot{d\vec{r}}$，总功使用一型曲线积分计算：$W=\int_L{\vec{F}\cdot{d\vec{r}}}$，当然也可以使用二型曲线积分：$W=\int_L{Pdx+Qdy}$。</p><p>当曲线$L$闭合的时候，会有一些不错的性质。闭合曲线会围成一个区域$D$，记其边界为$\partial{D}$<br>注意，区域$D$的边界路径可以有两个方向，这两个方向做的功显然互为相反数。习惯上记区域$D$在路径方向的左侧时记为正方向，记为$\partial{D^+}$。<br>曲线积分$\Gamma=\oint_{\partial{D^+}}{\vec{v}\cdot{d\vec{r}}}=\Gamma=\oint_{\partial{D^+}}{Pdx+Qdy}$成为区域$D$的环量。<br>【希腊字母$\Gamma$是$\gamma$的大写，读作”gamma伽马”】<br>三维环量定义类似。三维空间中的曲面$\Sigma$是有向的，它的边界的正方向用右手定则规定：右手四指围绕路径方向，右手大拇指与$\Sigma$正侧同向时，路径为正方向。</p><h2 id="2-2-环量密度"><a href="#2-2-环量密度" class="headerlink" title="2.2 环量密度"></a>2.2 环量密度</h2><p>当区域$D$逐渐缩小时，以一个点$(x,y)$为中心，构建一个边长为$2a$和$2b$的很小的矩形区域，研究一下这个区域的环量，令$a\rightarrow0$，$b\rightarrow0$，每条边的功都可以求出来。假设在这个小区域内的力是线性均匀变化的，那么下边的力$P$平均一下，就是其中点的力$P(x,y-b$，移动距离为$2a$，那么做功就是$W_1=P(x,y-b)2a$。其余以此类推。  </p><p>环量进行求和：$W=W_1+W_2+W_3+W_4$<br>注意到$P(x,y-b)-P(x,y+b)=-\frac{\partial{P}}{\partial{y}}2b$，因此：<br>$W=(W_1+W_3)+(W_2+W_4)$<br>$=-\frac{\partial{P}}{\partial{y}}2b2a+\frac{\partial{Q}}{\partial{x}}2a2b=(\frac{\partial{Q}}{\partial{x}}-\frac{\partial{P}}{\partial{y}})4ab$<br>这就是点$(x,y$附近的环量，是一个无穷小值。我们把这个环量除以该区域的面积$4ab$，得到的值$\frac{\partial{Q}}{\partial{x}}-\frac{\partial{P}}{\partial{y}}$称为环量面密度。</p><h2 id="2-3-旋度"><a href="#2-3-旋度" class="headerlink" title="2.3 旋度"></a>2.3 旋度</h2><p>对于一个空间中的点，考虑平行于三个坐标面的环量密度<br>路径正方向用右手定则确定：右手四指围绕路径方向，右手大拇指与坐标轴同向时，路径为正方向。<br>定义向量$\vec{v}=(x,y,z)$终点的<strong>旋度</strong>为<br>$rot(\vec{i}$或$curl(\vec{v})=(\frac{\partial{R}}{\partial{y}}-\frac{\partial{Q}}{\partial{z}})\vec{i}+(\frac{\partial{P}}{\partial{z}}-\frac{\partial{R}}{\partial{x}})\vec{j}+(\frac{\partial{Q}}{\partial{x}}-\frac{\partial{P}}{\partial{y}})\vec{k}$<br>旋度用算法表示为$\nabla\times\vec{v}$<br>旋度描述了向量场在该点附近造成旋转的程度。旋度是一个矢量。</p><h2 id="2-4-格林公式和斯托克斯公式"><a href="#2-4-格林公式和斯托克斯公式" class="headerlink" title="2.4 格林公式和斯托克斯公式"></a>2.4 格林公式和斯托克斯公式</h2><p>先考虑二维的情况，任何一个区域，都可以切割成小方块，两个小方向的环量之和等于拼起来的大方块的环量，这启发我们用新的方法来计算环量！<br>只要方块切得足够小，就可以用环量密度乘上微元面积来表示环量，即$(\frac{\partial{Q}}{\partial{x}}-\frac{\partial{P}}{\partial{y}})d\sigma$。<br>要求整个区域$D$的环量，那自然是把所有环量求和，即对上式求二重积分，这样格林公式就呼之欲出！<br><strong>Green格林公式</strong><br>$\oint_{\partial{D^+}}{Pdx+Qdy}=\iint_D(\frac{\partial{Q}}{\partial{x}}-\frac{\partial{P}}{\partial{y}})dxdy$<br>二维推广到三维，把曲面切割成微元，每个微元投影到三个坐标平面上，再用同样的思想，即可用曲面积分计算三维环量，这就是斯托克斯公式！<br><strong>Stokes斯托克斯公式</strong><br>$\oint_{\partial\Sigma^+}Pdx+Qdy+Rdz<br>=\iint_\Sigma(\frac{\partial{R}}{\partial{y}}-\frac{\partial{Q}}{\partial{z}})dydz+(\frac{\partial{P}}{\partial{z}}-\frac{\partial{R}}{\partial{x}})dzdx+(\frac{\partial{Q}}{\partial{x}}-\frac{\partial{P}}{\partial{y}})dxdy$<br>简记为$\oint_{\partial\Sigma^+}\vec{v}\cdot{d\vec{r}}=\iint_\Sigma\nabla\times\vec{v}\cdot{d\vec{S}}$<br>显然，斯托克斯公式是格林公式的推广，把斯托克斯公式投影到$xOy$平面上就变成了格林公式。</p><h1 id="3-通量、散度与高斯公式"><a href="#3-通量、散度与高斯公式" class="headerlink" title="3.通量、散度与高斯公式"></a>3.通量、散度与高斯公式</h1><h2 id="3-1-通量"><a href="#3-1-通量" class="headerlink" title="3.1 通量"></a>3.1 通量</h2><p>前面环量研究的是比曲线积分，现在研究的是闭曲面积分<br>设在点$(x,y,z)$处液体流量面密度为$\vec{v}$，曲面该处的法向量为$\vec{n}$，微元面积为$dS$，则该微元的液体流量为$\vec{v}\cdot\vec{n}dS=\vec{v}\cdot{d\vec{S}}$。该处曲面的液体流量就是曲面积分$\Phi=\iint_\Sigma\vec{v}\cdot{d\vec{S}}$，这就是通量。<br>【希腊字母$\Phi$是$\phi$的大写，读作”fai弗爱”】</p><h2 id="3-2散度"><a href="#3-2散度" class="headerlink" title="3.2散度"></a>3.2散度</h2><p>研究一下包含一个点的很小的闭曲面的通量。<br>将闭曲面近似为长方体，令$a,b,c\rightarrow0$，则其沿$x$轴方向的通量为<br>$[P(x+a,y,z)-P(x-a,y,z)]4ab=\frac{\partial{P}}{\partial{x}}2a4bc$<br>因此，该闭曲面的整体的通量为$(\frac{\partial{P}}{\partial{x}}+\frac{\partial{Q}}{\partial{y}}+\frac{\partial{R}}{\partial{z}})8abc$。<br>通量体密度被定义为$\vec{v}=(x,y,z)$的散度，记为<br>$div(\vec{v})=\frac{\partial{P}}{\partial{x}}+\frac{\partial{Q}}{\partial{y}}+\frac{\partial{R}}{\partial{z}}=\nabla\cdot\vec{v}$<br>散度描述了向量场在该点附近发散的程度。散度是标量。<br>举个例子，把向量场视为水流量场，从某一点流出或流入的水流量，由这一点的散度决定。散度为正，这一点为源点（相当于水龙头）；散度为负，这一点为汇点（相当于下水道）。</p><h3 id="3-3高斯公式"><a href="#3-3高斯公式" class="headerlink" title="3.3高斯公式"></a>3.3高斯公式</h3><p>同样使用切割的思想，把闭曲面包含的体切割成微元长方体，整个闭曲面的通量等于微元长方体的通量之和，求和使用三重积分。<br><strong>Gauss高斯公式</strong><br>$\oiint_{\partial{\Omega^+}}Pdydz+Qdzdx+Rdxdy=\iiint_\Omega(\frac{\partial{P}}{\partial{x}}+\frac{\partial{Q}}{\partial{y}}+\frac{\partial{R}}{\partial{z}})dV$<br>简记为$\oiint_{\partial{\Omega^+}}\vec{v}\cdot{d\vec{S}}=\iiint_\Omega(\nabla\cdot\vec{v})dV$<br>其中$\partial{\Omega^+}$的方向为$\Omega$向外。</p><h1 id="算符总结"><a href="#算符总结" class="headerlink" title="算符总结"></a>算符总结</h1><p>算符/算子：把函数映射为函数，即函数的函数。</p><h2 id="4-1-nabla-哈密顿-梯度算符"><a href="#4-1-nabla-哈密顿-梯度算符" class="headerlink" title="4.1 nabla/哈密顿/梯度算符"></a>4.1 nabla/哈密顿/梯度算符</h2><p>把数量场映射为向量场。<br>$\nabla=\frac{\partial}{\partial{x}}\vec{i}+\frac{\partial}{\partial{y}}\vec{j}+\frac{\partial}{\partial{z}}\vec{k}=(\frac{\partial}{\partial{x}}+\frac{\partial}{\partial{y}}+\frac{\partial}{\partial{z}})$  </p><h2 id="4-2-旋度算符"><a href="#4-2-旋度算符" class="headerlink" title="4.2 旋度算符"></a>4.2 旋度算符</h2><p>把向量场映射为向量场<br>$\nabla\times\vec{v}=\left|\begin{matrix}\vec{i} &amp; \vec{j} &amp; \vec{k} \\frac{\partial}{\partial{x}} &amp; \frac{\partial}{\partial{y}} &amp; \frac{\partial}{\partial{z}} \ P &amp; Q &amp; R \end{matrix}\right|$  </p><h2 id="4-3-散度算符"><a href="#4-3-散度算符" class="headerlink" title="4.3 散度算符"></a>4.3 散度算符</h2><p>把向量场映射为数量场。<br>$\nabla\cdot\vec{v}=\frac{\partial{P}}{\partial{x}}+\frac{\partial{Q}}{\partial{y}}+\frac{\partial{R}}{\partial{z}}$  </p><h2 id="4-4-laplace-拉普拉斯-调和算符"><a href="#4-4-laplace-拉普拉斯-调和算符" class="headerlink" title="4.4 laplace/拉普拉斯/调和算符"></a>4.4 laplace/拉普拉斯/调和算符</h2><p>$\Delta=\nabla^2=\nabla\cdot\nabla=\frac{\partial^2}{\partial{x^2}}+\frac{\partial^2}{\partial{y^2}}+\frac{\partial^2}{\partial{z^2}}$</p><h2 id="4-5-恒等式及特殊场"><a href="#4-5-恒等式及特殊场" class="headerlink" title="4.5 恒等式及特殊场"></a>4.5 恒等式及特殊场</h2><p>$\nabla\times(\nabla{z})\equiv0$，即梯度场的旋度为零，梯度场是无旋场/保守场/有势场，如重力场、静电场。<br>$\nabla\cdot(\nabla\times\vec{v})\equiv0$，即旋度场的散度为零，旋度场是无散场/无源场/管形场，如磁场、涡旋电场。<br>同时无散且无旋的向量场被称为调和场。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
